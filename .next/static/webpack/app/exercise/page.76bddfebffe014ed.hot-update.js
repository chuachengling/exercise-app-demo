"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/exercise/page",{

/***/ "(app-pages-browser)/./src/lib/services/exerciseService.ts":
/*!*********************************************!*\
  !*** ./src/lib/services/exerciseService.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createExercise: function() { return /* binding */ createExercise; },\n/* harmony export */   deleteExercise: function() { return /* binding */ deleteExercise; },\n/* harmony export */   getDefaultTypeData: function() { return /* binding */ getDefaultTypeData; },\n/* harmony export */   getExerciseStats: function() { return /* binding */ getExerciseStats; },\n/* harmony export */   getExercises: function() { return /* binding */ getExercises; },\n/* harmony export */   updateExercise: function() { return /* binding */ updateExercise; }\n/* harmony export */ });\n/* harmony import */ var _lib_types_exercise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/types/exercise */ \"(app-pages-browser)/./src/lib/types/exercise.ts\");\n\n// Storage keys\nconst EXERCISES_STORAGE_KEY = \"exercise_app_exercises\";\n// Utility functions for local storage\nfunction getStoredExercises() {\n    if (false) {}\n    try {\n        const stored = localStorage.getItem(EXERCISES_STORAGE_KEY);\n        if (!stored) return [];\n        const exercises = JSON.parse(stored);\n        return exercises.map((exercise)=>({\n                ...exercise,\n                date: new Date(exercise.date),\n                createdAt: new Date(exercise.createdAt),\n                updatedAt: new Date(exercise.updatedAt)\n            }));\n    } catch (e) {\n        return [];\n    }\n}\nfunction saveExercises(exercises) {\n    if (false) {}\n    localStorage.setItem(EXERCISES_STORAGE_KEY, JSON.stringify(exercises));\n}\n// Generate mock exercises for demo\nfunction generateMockExercises(userId) {\n    const now = new Date();\n    const mockExercises = [\n        {\n            id: \"ex_\".concat(Date.now(), \"_1\"),\n            userId,\n            type: _lib_types_exercise__WEBPACK_IMPORTED_MODULE_0__.ExerciseType.HIIT,\n            name: \"Morning HIIT Session\",\n            duration: 30,\n            intensity: _lib_types_exercise__WEBPACK_IMPORTED_MODULE_0__.IntensityLevel.HIGH,\n            date: new Date(now.getTime() - 86400000),\n            notes: \"Great energy today, pushed through all rounds\",\n            caloriesBurned: 250,\n            createdAt: new Date(now.getTime() - 86400000),\n            updatedAt: new Date(now.getTime() - 86400000),\n            typeSpecificData: {\n                rounds: 5,\n                workInterval: 45,\n                restInterval: 15\n            }\n        },\n        {\n            id: \"ex_\".concat(Date.now(), \"_2\"),\n            userId,\n            type: _lib_types_exercise__WEBPACK_IMPORTED_MODULE_0__.ExerciseType.WEIGHTLIFTING,\n            name: \"Upper Body Strength\",\n            duration: 45,\n            intensity: _lib_types_exercise__WEBPACK_IMPORTED_MODULE_0__.IntensityLevel.MODERATE,\n            date: new Date(now.getTime() - 172800000),\n            notes: \"Focused on form over weight\",\n            caloriesBurned: 180,\n            createdAt: new Date(now.getTime() - 172800000),\n            updatedAt: new Date(now.getTime() - 172800000),\n            typeSpecificData: {\n                exercises: [\n                    {\n                        exercise: \"Bench Press\",\n                        sets: 3,\n                        reps: 10,\n                        weight: 70,\n                        restTime: 90\n                    },\n                    {\n                        exercise: \"Pull-ups\",\n                        sets: 3,\n                        reps: 8,\n                        weight: 0,\n                        restTime: 60\n                    }\n                ],\n                totalWeight: 2100\n            }\n        },\n        {\n            id: \"ex_\".concat(Date.now(), \"_3\"),\n            userId,\n            type: _lib_types_exercise__WEBPACK_IMPORTED_MODULE_0__.ExerciseType.CARDIO,\n            name: \"Evening Run\",\n            duration: 35,\n            intensity: _lib_types_exercise__WEBPACK_IMPORTED_MODULE_0__.IntensityLevel.MODERATE,\n            date: new Date(now.getTime() - 259200000),\n            notes: \"Beautiful weather for a run\",\n            caloriesBurned: 320,\n            createdAt: new Date(now.getTime() - 259200000),\n            updatedAt: new Date(now.getTime() - 259200000),\n            typeSpecificData: {\n                distance: 5.2,\n                pace: 6.7,\n                heartRate: [\n                    120,\n                    135,\n                    142,\n                    138,\n                    125\n                ]\n            }\n        }\n    ];\n    return mockExercises;\n}\n// Exercise service functions\nasync function createExercise(formData, userId) {\n    // Simulate API delay\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    const newExercise = {\n        id: \"ex_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9)),\n        userId,\n        type: formData.type,\n        name: formData.name.trim(),\n        duration: formData.duration,\n        intensity: formData.intensity,\n        date: new Date(formData.date),\n        notes: formData.notes.trim() || undefined,\n        caloriesBurned: formData.caloriesBurned || undefined,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        typeSpecificData: formData.typeSpecificData\n    };\n    const exercises = getStoredExercises();\n    exercises.unshift(newExercise); // Add to beginning\n    saveExercises(exercises);\n    return newExercise;\n}\nasync function getExercises(userId, filters) {\n    // Simulate API delay\n    await new Promise((resolve)=>setTimeout(resolve, 200));\n    let exercises = getStoredExercises().filter((ex)=>ex.userId === userId);\n    // Note: Mock data generation disabled - users will start with empty state\n    // This ensures new exercise entries are properly displayed without confusion\n    // if (exercises.length === 0) {\n    //   const mockExercises = generateMockExercises(userId);\n    //   saveExercises(mockExercises);\n    //   exercises = mockExercises;\n    // }\n    // Apply filters\n    if (filters) {\n        if (filters.type) {\n            exercises = exercises.filter((ex)=>ex.type === filters.type);\n        }\n        if (filters.intensity) {\n            exercises = exercises.filter((ex)=>ex.intensity === filters.intensity);\n        }\n        if (filters.searchQuery) {\n            const query = filters.searchQuery.toLowerCase();\n            exercises = exercises.filter((ex)=>{\n                var _ex_notes;\n                return ex.name.toLowerCase().includes(query) || ((_ex_notes = ex.notes) === null || _ex_notes === void 0 ? void 0 : _ex_notes.toLowerCase().includes(query)) || ex.type.toLowerCase().includes(query);\n            });\n        }\n        if (filters.dateRange) {\n            exercises = exercises.filter((ex)=>ex.date >= filters.dateRange.start && ex.date <= filters.dateRange.end);\n        }\n    }\n    // Sort by date (most recent first)\n    return exercises.sort((a, b)=>b.date.getTime() - a.date.getTime());\n}\nasync function updateExercise(exerciseId, updates) {\n    // Simulate API delay\n    await new Promise((resolve)=>setTimeout(resolve, 400));\n    const exercises = getStoredExercises();\n    const exerciseIndex = exercises.findIndex((ex)=>ex.id === exerciseId);\n    if (exerciseIndex === -1) {\n        throw new Error(\"Exercise not found\");\n    }\n    const updatedExercise = {\n        ...exercises[exerciseIndex],\n        ...updates,\n        date: updates.date ? new Date(updates.date) : exercises[exerciseIndex].date,\n        updatedAt: new Date()\n    };\n    exercises[exerciseIndex] = updatedExercise;\n    saveExercises(exercises);\n    return updatedExercise;\n}\nasync function deleteExercise(exerciseId) {\n    // Simulate API delay\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const exercises = getStoredExercises();\n    const filteredExercises = exercises.filter((ex)=>ex.id !== exerciseId);\n    if (filteredExercises.length === exercises.length) {\n        throw new Error(\"Exercise not found\");\n    }\n    saveExercises(filteredExercises);\n}\nasync function getExerciseStats(userId) {\n    // Simulate API delay\n    await new Promise((resolve)=>setTimeout(resolve, 150));\n    const exercises = await getExercises(userId);\n    if (exercises.length === 0) {\n        return {\n            totalExercises: 0,\n            totalDuration: 0,\n            averageIntensity: 0,\n            favoriteType: _lib_types_exercise__WEBPACK_IMPORTED_MODULE_0__.ExerciseType.CARDIO,\n            currentStreak: 0,\n            longestStreak: 0,\n            weeklyGoalProgress: 0,\n            exercisesThisWeek: 0,\n            exercisesThisMonth: 0,\n            exercisesByType: {},\n            intensityDistribution: {},\n            weeklyData: []\n        };\n    }\n    const totalExercises = exercises.length;\n    const totalDuration = exercises.reduce((sum, ex)=>sum + ex.duration, 0);\n    // Calculate average intensity (convert to numeric scale)\n    const intensityValues = {\n        [_lib_types_exercise__WEBPACK_IMPORTED_MODULE_0__.IntensityLevel.LOW]: 1,\n        [_lib_types_exercise__WEBPACK_IMPORTED_MODULE_0__.IntensityLevel.MODERATE]: 2,\n        [_lib_types_exercise__WEBPACK_IMPORTED_MODULE_0__.IntensityLevel.HIGH]: 3,\n        [_lib_types_exercise__WEBPACK_IMPORTED_MODULE_0__.IntensityLevel.MAXIMUM]: 4\n    };\n    const averageIntensity = exercises.reduce((sum, ex)=>sum + intensityValues[ex.intensity], 0) / exercises.length;\n    // Count exercises by type\n    const exercisesByType = exercises.reduce((counts, ex)=>{\n        counts[ex.type] = (counts[ex.type] || 0) + 1;\n        return counts;\n    }, {});\n    // Find favorite type\n    const favoriteType = Object.entries(exercisesByType).reduce((a, b)=>exercisesByType[a[0]] > exercisesByType[b[0]] ? a : b)[0];\n    // Count exercises by intensity\n    const intensityDistribution = exercises.reduce((counts, ex)=>{\n        counts[ex.intensity] = (counts[ex.intensity] || 0) + 1;\n        return counts;\n    }, {});\n    // Calculate streaks\n    const today = new Date();\n    const uniqueDates = Array.from(new Set(exercises.map((ex)=>ex.date.toDateString()))).sort((a, b)=>new Date(b).getTime() - new Date(a).getTime());\n    let currentStreak = 0;\n    let longestStreak = 0;\n    let tempStreak = 0;\n    for(let i = 0; i < uniqueDates.length; i++){\n        const exerciseDate = new Date(uniqueDates[i]);\n        const daysDiff = Math.floor((today.getTime() - exerciseDate.getTime()) / (1000 * 60 * 60 * 24));\n        if (i === 0 && daysDiff <= 1) {\n            currentStreak = 1;\n            tempStreak = 1;\n        } else if (i > 0) {\n            const prevDate = new Date(uniqueDates[i - 1]);\n            const daysBetween = Math.floor((prevDate.getTime() - exerciseDate.getTime()) / (1000 * 60 * 60 * 24));\n            if (daysBetween === 1) {\n                tempStreak++;\n                if (i === 1 && daysDiff <= 1) {\n                    currentStreak = tempStreak;\n                }\n            } else {\n                longestStreak = Math.max(longestStreak, tempStreak);\n                tempStreak = 1;\n            }\n        }\n    }\n    longestStreak = Math.max(longestStreak, tempStreak, currentStreak);\n    // Calculate this week's exercises\n    const weekStart = new Date(today);\n    weekStart.setDate(today.getDate() - today.getDay());\n    weekStart.setHours(0, 0, 0, 0);\n    const exercisesThisWeek = exercises.filter((ex)=>ex.date >= weekStart).length;\n    // Calculate this month's exercises\n    const monthStart = new Date(today.getFullYear(), today.getMonth(), 1);\n    const exercisesThisMonth = exercises.filter((ex)=>ex.date >= monthStart).length;\n    // Calculate weekly goal progress (assuming 5 exercises per week)\n    const weeklyGoalProgress = Math.min(100, exercisesThisWeek / 5 * 100);\n    // Generate weekly data for the last 14 days\n    const weeklyData = [];\n    for(let i = 13; i >= 0; i--){\n        const date = new Date(today);\n        date.setDate(today.getDate() - i);\n        date.setHours(0, 0, 0, 0);\n        const nextDay = new Date(date);\n        nextDay.setDate(date.getDate() + 1);\n        const dayExercises = exercises.filter((ex)=>ex.date >= date && ex.date < nextDay);\n        weeklyData.push({\n            date: date.toISOString(),\n            exercises: dayExercises.length,\n            duration: dayExercises.reduce((sum, ex)=>sum + ex.duration, 0)\n        });\n    }\n    return {\n        totalExercises,\n        totalDuration,\n        averageIntensity,\n        favoriteType,\n        currentStreak,\n        longestStreak,\n        weeklyGoalProgress,\n        exercisesThisWeek,\n        exercisesThisMonth,\n        exercisesByType,\n        intensityDistribution,\n        weeklyData\n    };\n}\n// Get default type-specific data for forms\nfunction getDefaultTypeData(type) {\n    switch(type){\n        case _lib_types_exercise__WEBPACK_IMPORTED_MODULE_0__.ExerciseType.HIIT:\n            return {\n                rounds: 0,\n                workInterval: 0,\n                restInterval: 0\n            };\n        case _lib_types_exercise__WEBPACK_IMPORTED_MODULE_0__.ExerciseType.WEIGHTLIFTING:\n        case _lib_types_exercise__WEBPACK_IMPORTED_MODULE_0__.ExerciseType.ARMS:\n            return {\n                exercises: [],\n                totalWeight: 0\n            };\n        case _lib_types_exercise__WEBPACK_IMPORTED_MODULE_0__.ExerciseType.CARDIO:\n            return {\n                distance: 0,\n                pace: 0,\n                heartRate: []\n            };\n        case _lib_types_exercise__WEBPACK_IMPORTED_MODULE_0__.ExerciseType.SPORTS:\n            return {\n                sport: \"\",\n                score: \"\",\n                opponent: \"\"\n            };\n        default:\n            return {};\n    }\n}\n// Default export object\nconst exerciseService = {\n    createExercise,\n    getExercises,\n    updateExercise,\n    deleteExercise,\n    getExerciseStats,\n    getDefaultTypeData\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (exerciseService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc2VydmljZXMvZXhlcmNpc2VTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBZ0k7QUFFaEksZUFBZTtBQUNmLE1BQU1FLHdCQUF3QjtBQUU5QixzQ0FBc0M7QUFDdEMsU0FBU0M7SUFDUCxJQUFJLEtBQWtCLEVBQWEsRUFBVTtJQUM3QyxJQUFJO1FBQ0YsTUFBTUMsU0FBU0MsYUFBYUMsT0FBTyxDQUFDSjtRQUNwQyxJQUFJLENBQUNFLFFBQVEsT0FBTyxFQUFFO1FBRXRCLE1BQU1HLFlBQVlDLEtBQUtDLEtBQUssQ0FBQ0w7UUFDN0IsT0FBT0csVUFBVUcsR0FBRyxDQUFDLENBQUNDLFdBQW1CO2dCQUN2QyxHQUFHQSxRQUFRO2dCQUNYQyxNQUFNLElBQUlDLEtBQUtGLFNBQVNDLElBQUk7Z0JBQzVCRSxXQUFXLElBQUlELEtBQUtGLFNBQVNHLFNBQVM7Z0JBQ3RDQyxXQUFXLElBQUlGLEtBQUtGLFNBQVNJLFNBQVM7WUFDeEM7SUFDRixFQUFFLFVBQU07UUFDTixPQUFPLEVBQUU7SUFDWDtBQUNGO0FBRUEsU0FBU0MsY0FBY1QsU0FBcUI7SUFDMUMsSUFBSSxLQUFrQixFQUFhLEVBQU87SUFDMUNGLGFBQWFZLE9BQU8sQ0FBQ2YsdUJBQXVCTSxLQUFLVSxTQUFTLENBQUNYO0FBQzdEO0FBRUEsbUNBQW1DO0FBQ25DLFNBQVNZLHNCQUFzQkMsTUFBYztJQUMzQyxNQUFNQyxNQUFNLElBQUlSO0lBQ2hCLE1BQU1TLGdCQUE0QjtRQUNoQztZQUNFQyxJQUFJLE1BQWlCLE9BQVhWLEtBQUtRLEdBQUcsSUFBRztZQUNyQkQ7WUFDQUksTUFBTXhCLDZEQUFZQSxDQUFDeUIsSUFBSTtZQUN2QkMsTUFBTTtZQUNOQyxVQUFVO1lBQ1ZDLFdBQVczQiwrREFBY0EsQ0FBQzRCLElBQUk7WUFDOUJqQixNQUFNLElBQUlDLEtBQUtRLElBQUlTLE9BQU8sS0FBSztZQUMvQkMsT0FBTztZQUNQQyxnQkFBZ0I7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QUNOQyxXQUFXLEVBQUU7WUFDZjtRQUNGLEtBQUsvQyw2REFBWUEsQ0FBQ3VJLE1BQU07WUFDdEIsT0FBTztnQkFDTEMsT0FBTztnQkFDUEMsT0FBTztnQkFDUEMsVUFBVTtZQUNaO1FBQ0Y7WUFDRSxPQUFPLENBQUM7SUFDWjtBQUNGO0FBRUEsd0JBQXdCO0FBQ3hCLE1BQU1DLGtCQUFrQjtJQUN0QjNGO0lBQ0FhO0lBQ0FjO0lBQ0FPO0lBQ0FHO0lBQ0FnRDtBQUNGO0FBRUEsK0RBQWVNLGVBQWVBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9zZXJ2aWNlcy9leGVyY2lzZVNlcnZpY2UudHM/OTVjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFeGVyY2lzZSwgRXhlcmNpc2VGb3JtRGF0YSwgRXhlcmNpc2VUeXBlLCBJbnRlbnNpdHlMZXZlbCwgRXhlcmNpc2VGaWx0ZXJzLCBFeGVyY2lzZVN0YXRzIH0gZnJvbSAnQC9saWIvdHlwZXMvZXhlcmNpc2UnO1xuXG4vLyBTdG9yYWdlIGtleXNcbmNvbnN0IEVYRVJDSVNFU19TVE9SQUdFX0tFWSA9ICdleGVyY2lzZV9hcHBfZXhlcmNpc2VzJztcblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGxvY2FsIHN0b3JhZ2VcbmZ1bmN0aW9uIGdldFN0b3JlZEV4ZXJjaXNlcygpOiBFeGVyY2lzZVtdIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gW107XG4gIHRyeSB7XG4gICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oRVhFUkNJU0VTX1NUT1JBR0VfS0VZKTtcbiAgICBpZiAoIXN0b3JlZCkgcmV0dXJuIFtdO1xuICAgIFxuICAgIGNvbnN0IGV4ZXJjaXNlcyA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICByZXR1cm4gZXhlcmNpc2VzLm1hcCgoZXhlcmNpc2U6IGFueSkgPT4gKHtcbiAgICAgIC4uLmV4ZXJjaXNlLFxuICAgICAgZGF0ZTogbmV3IERhdGUoZXhlcmNpc2UuZGF0ZSksXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKGV4ZXJjaXNlLmNyZWF0ZWRBdCksXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKGV4ZXJjaXNlLnVwZGF0ZWRBdClcbiAgICB9KSk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzYXZlRXhlcmNpc2VzKGV4ZXJjaXNlczogRXhlcmNpc2VbXSk6IHZvaWQge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oRVhFUkNJU0VTX1NUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShleGVyY2lzZXMpKTtcbn1cblxuLy8gR2VuZXJhdGUgbW9jayBleGVyY2lzZXMgZm9yIGRlbW9cbmZ1bmN0aW9uIGdlbmVyYXRlTW9ja0V4ZXJjaXNlcyh1c2VySWQ6IHN0cmluZyk6IEV4ZXJjaXNlW10ge1xuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICBjb25zdCBtb2NrRXhlcmNpc2VzOiBFeGVyY2lzZVtdID0gW1xuICAgIHtcbiAgICAgIGlkOiBgZXhfJHtEYXRlLm5vdygpfV8xYCxcbiAgICAgIHVzZXJJZCxcbiAgICAgIHR5cGU6IEV4ZXJjaXNlVHlwZS5ISUlULFxuICAgICAgbmFtZTogJ01vcm5pbmcgSElJVCBTZXNzaW9uJyxcbiAgICAgIGR1cmF0aW9uOiAzMCxcbiAgICAgIGludGVuc2l0eTogSW50ZW5zaXR5TGV2ZWwuSElHSCxcbiAgICAgIGRhdGU6IG5ldyBEYXRlKG5vdy5nZXRUaW1lKCkgLSA4NjQwMDAwMCksIC8vIFllc3RlcmRheVxuICAgICAgbm90ZXM6ICdHcmVhdCBlbmVyZ3kgdG9kYXksIHB1c2hlZCB0aHJvdWdoIGFsbCByb3VuZHMnLFxuICAgICAgY2Fsb3JpZXNCdXJuZWQ6IDI1MCxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUobm93LmdldFRpbWUoKSAtIDg2NDAwMDAwKSxcbiAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUobm93LmdldFRpbWUoKSAtIDg2NDAwMDAwKSxcbiAgICAgIHR5cGVTcGVjaWZpY0RhdGE6IHtcbiAgICAgICAgcm91bmRzOiA1LFxuICAgICAgICB3b3JrSW50ZXJ2YWw6IDQ1LFxuICAgICAgICByZXN0SW50ZXJ2YWw6IDE1XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogYGV4XyR7RGF0ZS5ub3coKX1fMmAsXG4gICAgICB1c2VySWQsXG4gICAgICB0eXBlOiBFeGVyY2lzZVR5cGUuV0VJR0hUTElGVElORyxcbiAgICAgIG5hbWU6ICdVcHBlciBCb2R5IFN0cmVuZ3RoJyxcbiAgICAgIGR1cmF0aW9uOiA0NSxcbiAgICAgIGludGVuc2l0eTogSW50ZW5zaXR5TGV2ZWwuTU9ERVJBVEUsXG4gICAgICBkYXRlOiBuZXcgRGF0ZShub3cuZ2V0VGltZSgpIC0gMTcyODAwMDAwKSwgLy8gMiBkYXlzIGFnb1xuICAgICAgbm90ZXM6ICdGb2N1c2VkIG9uIGZvcm0gb3ZlciB3ZWlnaHQnLFxuICAgICAgY2Fsb3JpZXNCdXJuZWQ6IDE4MCxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUobm93LmdldFRpbWUoKSAtIDE3MjgwMDAwMCksXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKG5vdy5nZXRUaW1lKCkgLSAxNzI4MDAwMDApLFxuICAgICAgdHlwZVNwZWNpZmljRGF0YToge1xuICAgICAgICBleGVyY2lzZXM6IFtcbiAgICAgICAgICB7IGV4ZXJjaXNlOiAnQmVuY2ggUHJlc3MnLCBzZXRzOiAzLCByZXBzOiAxMCwgd2VpZ2h0OiA3MCwgcmVzdFRpbWU6IDkwIH0sXG4gICAgICAgICAgeyBleGVyY2lzZTogJ1B1bGwtdXBzJywgc2V0czogMywgcmVwczogOCwgd2VpZ2h0OiAwLCByZXN0VGltZTogNjAgfVxuICAgICAgICBdLFxuICAgICAgICB0b3RhbFdlaWdodDogMjEwMFxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IGBleF8ke0RhdGUubm93KCl9XzNgLFxuICAgICAgdXNlcklkLFxuICAgICAgdHlwZTogRXhlcmNpc2VUeXBlLkNBUkRJTyxcbiAgICAgIG5hbWU6ICdFdmVuaW5nIFJ1bicsXG4gICAgICBkdXJhdGlvbjogMzUsXG4gICAgICBpbnRlbnNpdHk6IEludGVuc2l0eUxldmVsLk1PREVSQVRFLFxuICAgICAgZGF0ZTogbmV3IERhdGUobm93LmdldFRpbWUoKSAtIDI1OTIwMDAwMCksIC8vIDMgZGF5cyBhZ29cbiAgICAgIG5vdGVzOiAnQmVhdXRpZnVsIHdlYXRoZXIgZm9yIGEgcnVuJyxcbiAgICAgIGNhbG9yaWVzQnVybmVkOiAzMjAsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKG5vdy5nZXRUaW1lKCkgLSAyNTkyMDAwMDApLFxuICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShub3cuZ2V0VGltZSgpIC0gMjU5MjAwMDAwKSxcbiAgICAgIHR5cGVTcGVjaWZpY0RhdGE6IHtcbiAgICAgICAgZGlzdGFuY2U6IDUuMixcbiAgICAgICAgcGFjZTogNi43LCAvLyBtaW4va21cbiAgICAgICAgaGVhcnRSYXRlOiBbMTIwLCAxMzUsIDE0MiwgMTM4LCAxMjVdXG4gICAgICB9XG4gICAgfVxuICBdO1xuXG4gIHJldHVybiBtb2NrRXhlcmNpc2VzO1xufVxuXG4vLyBFeGVyY2lzZSBzZXJ2aWNlIGZ1bmN0aW9uc1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUV4ZXJjaXNlKGZvcm1EYXRhOiBFeGVyY2lzZUZvcm1EYXRhLCB1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8RXhlcmNpc2U+IHtcbiAgLy8gU2ltdWxhdGUgQVBJIGRlbGF5XG4gIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcblxuICBjb25zdCBuZXdFeGVyY2lzZTogRXhlcmNpc2UgPSB7XG4gICAgaWQ6IGBleF8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWAsXG4gICAgdXNlcklkLFxuICAgIHR5cGU6IGZvcm1EYXRhLnR5cGUsXG4gICAgbmFtZTogZm9ybURhdGEubmFtZS50cmltKCksXG4gICAgZHVyYXRpb246IGZvcm1EYXRhLmR1cmF0aW9uLFxuICAgIGludGVuc2l0eTogZm9ybURhdGEuaW50ZW5zaXR5LFxuICAgIGRhdGU6IG5ldyBEYXRlKGZvcm1EYXRhLmRhdGUpLFxuICAgIG5vdGVzOiBmb3JtRGF0YS5ub3Rlcy50cmltKCkgfHwgdW5kZWZpbmVkLFxuICAgIGNhbG9yaWVzQnVybmVkOiBmb3JtRGF0YS5jYWxvcmllc0J1cm5lZCB8fCB1bmRlZmluZWQsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICB0eXBlU3BlY2lmaWNEYXRhOiBmb3JtRGF0YS50eXBlU3BlY2lmaWNEYXRhXG4gIH07XG5cbiAgY29uc3QgZXhlcmNpc2VzID0gZ2V0U3RvcmVkRXhlcmNpc2VzKCk7XG4gIGV4ZXJjaXNlcy51bnNoaWZ0KG5ld0V4ZXJjaXNlKTsgLy8gQWRkIHRvIGJlZ2lubmluZ1xuICBzYXZlRXhlcmNpc2VzKGV4ZXJjaXNlcyk7XG5cbiAgcmV0dXJuIG5ld0V4ZXJjaXNlO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RXhlcmNpc2VzKHVzZXJJZDogc3RyaW5nLCBmaWx0ZXJzPzogRXhlcmNpc2VGaWx0ZXJzKTogUHJvbWlzZTxFeGVyY2lzZVtdPiB7XG4gIC8vIFNpbXVsYXRlIEFQSSBkZWxheVxuICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwKSk7XG5cbiAgbGV0IGV4ZXJjaXNlcyA9IGdldFN0b3JlZEV4ZXJjaXNlcygpLmZpbHRlcihleCA9PiBleC51c2VySWQgPT09IHVzZXJJZCk7XG5cbiAgLy8gTm90ZTogTW9jayBkYXRhIGdlbmVyYXRpb24gZGlzYWJsZWQgLSB1c2VycyB3aWxsIHN0YXJ0IHdpdGggZW1wdHkgc3RhdGVcbiAgLy8gVGhpcyBlbnN1cmVzIG5ldyBleGVyY2lzZSBlbnRyaWVzIGFyZSBwcm9wZXJseSBkaXNwbGF5ZWQgd2l0aG91dCBjb25mdXNpb25cbiAgLy8gaWYgKGV4ZXJjaXNlcy5sZW5ndGggPT09IDApIHtcbiAgLy8gICBjb25zdCBtb2NrRXhlcmNpc2VzID0gZ2VuZXJhdGVNb2NrRXhlcmNpc2VzKHVzZXJJZCk7XG4gIC8vICAgc2F2ZUV4ZXJjaXNlcyhtb2NrRXhlcmNpc2VzKTtcbiAgLy8gICBleGVyY2lzZXMgPSBtb2NrRXhlcmNpc2VzO1xuICAvLyB9XG5cbiAgLy8gQXBwbHkgZmlsdGVyc1xuICBpZiAoZmlsdGVycykge1xuICAgIGlmIChmaWx0ZXJzLnR5cGUpIHtcbiAgICAgIGV4ZXJjaXNlcyA9IGV4ZXJjaXNlcy5maWx0ZXIoZXggPT4gZXgudHlwZSA9PT0gZmlsdGVycy50eXBlKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGZpbHRlcnMuaW50ZW5zaXR5KSB7XG4gICAgICBleGVyY2lzZXMgPSBleGVyY2lzZXMuZmlsdGVyKGV4ID0+IGV4LmludGVuc2l0eSA9PT0gZmlsdGVycy5pbnRlbnNpdHkpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZmlsdGVycy5zZWFyY2hRdWVyeSkge1xuICAgICAgY29uc3QgcXVlcnkgPSBmaWx0ZXJzLnNlYXJjaFF1ZXJ5LnRvTG93ZXJDYXNlKCk7XG4gICAgICBleGVyY2lzZXMgPSBleGVyY2lzZXMuZmlsdGVyKGV4ID0+IFxuICAgICAgICBleC5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocXVlcnkpIHx8XG4gICAgICAgIGV4Lm5vdGVzPy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHF1ZXJ5KSB8fFxuICAgICAgICBleC50eXBlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocXVlcnkpXG4gICAgICApO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZmlsdGVycy5kYXRlUmFuZ2UpIHtcbiAgICAgIGV4ZXJjaXNlcyA9IGV4ZXJjaXNlcy5maWx0ZXIoZXggPT4gXG4gICAgICAgIGV4LmRhdGUgPj0gZmlsdGVycy5kYXRlUmFuZ2UhLnN0YXJ0ICYmIFxuICAgICAgICBleC5kYXRlIDw9IGZpbHRlcnMuZGF0ZVJhbmdlIS5lbmRcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLy8gU29ydCBieSBkYXRlIChtb3N0IHJlY2VudCBmaXJzdClcbiAgcmV0dXJuIGV4ZXJjaXNlcy5zb3J0KChhLCBiKSA9PiBiLmRhdGUuZ2V0VGltZSgpIC0gYS5kYXRlLmdldFRpbWUoKSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVFeGVyY2lzZShleGVyY2lzZUlkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8RXhlcmNpc2VGb3JtRGF0YT4pOiBQcm9taXNlPEV4ZXJjaXNlPiB7XG4gIC8vIFNpbXVsYXRlIEFQSSBkZWxheVxuICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNDAwKSk7XG5cbiAgY29uc3QgZXhlcmNpc2VzID0gZ2V0U3RvcmVkRXhlcmNpc2VzKCk7XG4gIGNvbnN0IGV4ZXJjaXNlSW5kZXggPSBleGVyY2lzZXMuZmluZEluZGV4KGV4ID0+IGV4LmlkID09PSBleGVyY2lzZUlkKTtcblxuICBpZiAoZXhlcmNpc2VJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4ZXJjaXNlIG5vdCBmb3VuZCcpO1xuICB9XG5cbiAgY29uc3QgdXBkYXRlZEV4ZXJjaXNlID0ge1xuICAgIC4uLmV4ZXJjaXNlc1tleGVyY2lzZUluZGV4XSxcbiAgICAuLi51cGRhdGVzLFxuICAgIGRhdGU6IHVwZGF0ZXMuZGF0ZSA/IG5ldyBEYXRlKHVwZGF0ZXMuZGF0ZSkgOiBleGVyY2lzZXNbZXhlcmNpc2VJbmRleF0uZGF0ZSxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKClcbiAgfTtcblxuICBleGVyY2lzZXNbZXhlcmNpc2VJbmRleF0gPSB1cGRhdGVkRXhlcmNpc2U7XG4gIHNhdmVFeGVyY2lzZXMoZXhlcmNpc2VzKTtcblxuICByZXR1cm4gdXBkYXRlZEV4ZXJjaXNlO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlRXhlcmNpc2UoZXhlcmNpc2VJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gIC8vIFNpbXVsYXRlIEFQSSBkZWxheVxuICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSk7XG5cbiAgY29uc3QgZXhlcmNpc2VzID0gZ2V0U3RvcmVkRXhlcmNpc2VzKCk7XG4gIGNvbnN0IGZpbHRlcmVkRXhlcmNpc2VzID0gZXhlcmNpc2VzLmZpbHRlcihleCA9PiBleC5pZCAhPT0gZXhlcmNpc2VJZCk7XG4gIFxuICBpZiAoZmlsdGVyZWRFeGVyY2lzZXMubGVuZ3RoID09PSBleGVyY2lzZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeGVyY2lzZSBub3QgZm91bmQnKTtcbiAgfVxuICBcbiAgc2F2ZUV4ZXJjaXNlcyhmaWx0ZXJlZEV4ZXJjaXNlcyk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRFeGVyY2lzZVN0YXRzKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxFeGVyY2lzZVN0YXRzPiB7XG4gIC8vIFNpbXVsYXRlIEFQSSBkZWxheVxuICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTUwKSk7XG5cbiAgY29uc3QgZXhlcmNpc2VzID0gYXdhaXQgZ2V0RXhlcmNpc2VzKHVzZXJJZCk7XG4gIFxuICBpZiAoZXhlcmNpc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b3RhbEV4ZXJjaXNlczogMCxcbiAgICAgIHRvdGFsRHVyYXRpb246IDAsXG4gICAgICBhdmVyYWdlSW50ZW5zaXR5OiAwLFxuICAgICAgZmF2b3JpdGVUeXBlOiBFeGVyY2lzZVR5cGUuQ0FSRElPLFxuICAgICAgY3VycmVudFN0cmVhazogMCxcbiAgICAgIGxvbmdlc3RTdHJlYWs6IDAsXG4gICAgICB3ZWVrbHlHb2FsUHJvZ3Jlc3M6IDAsXG4gICAgICBleGVyY2lzZXNUaGlzV2VlazogMCxcbiAgICAgIGV4ZXJjaXNlc1RoaXNNb250aDogMCxcbiAgICAgIGV4ZXJjaXNlc0J5VHlwZToge30gYXMgUmVjb3JkPEV4ZXJjaXNlVHlwZSwgbnVtYmVyPixcbiAgICAgIGludGVuc2l0eURpc3RyaWJ1dGlvbjoge30gYXMgUmVjb3JkPEludGVuc2l0eUxldmVsLCBudW1iZXI+LFxuICAgICAgd2Vla2x5RGF0YTogW11cbiAgICB9O1xuICB9XG5cbiAgY29uc3QgdG90YWxFeGVyY2lzZXMgPSBleGVyY2lzZXMubGVuZ3RoO1xuICBjb25zdCB0b3RhbER1cmF0aW9uID0gZXhlcmNpc2VzLnJlZHVjZSgoc3VtLCBleCkgPT4gc3VtICsgZXguZHVyYXRpb24sIDApO1xuICBcbiAgLy8gQ2FsY3VsYXRlIGF2ZXJhZ2UgaW50ZW5zaXR5IChjb252ZXJ0IHRvIG51bWVyaWMgc2NhbGUpXG4gIGNvbnN0IGludGVuc2l0eVZhbHVlcyA9IHtcbiAgICBbSW50ZW5zaXR5TGV2ZWwuTE9XXTogMSxcbiAgICBbSW50ZW5zaXR5TGV2ZWwuTU9ERVJBVEVdOiAyLFxuICAgIFtJbnRlbnNpdHlMZXZlbC5ISUdIXTogMyxcbiAgICBbSW50ZW5zaXR5TGV2ZWwuTUFYSU1VTV06IDRcbiAgfTtcbiAgY29uc3QgYXZlcmFnZUludGVuc2l0eSA9IGV4ZXJjaXNlcy5yZWR1Y2UoKHN1bSwgZXgpID0+IHN1bSArIGludGVuc2l0eVZhbHVlc1tleC5pbnRlbnNpdHldLCAwKSAvIGV4ZXJjaXNlcy5sZW5ndGg7XG4gIFxuICAvLyBDb3VudCBleGVyY2lzZXMgYnkgdHlwZVxuICBjb25zdCBleGVyY2lzZXNCeVR5cGUgPSBleGVyY2lzZXMucmVkdWNlKChjb3VudHMsIGV4KSA9PiB7XG4gICAgY291bnRzW2V4LnR5cGVdID0gKGNvdW50c1tleC50eXBlXSB8fCAwKSArIDE7XG4gICAgcmV0dXJuIGNvdW50cztcbiAgfSwge30gYXMgUmVjb3JkPEV4ZXJjaXNlVHlwZSwgbnVtYmVyPik7XG4gIFxuICAvLyBGaW5kIGZhdm9yaXRlIHR5cGVcbiAgY29uc3QgZmF2b3JpdGVUeXBlID0gT2JqZWN0LmVudHJpZXMoZXhlcmNpc2VzQnlUeXBlKS5yZWR1Y2UoKGEsIGIpID0+IFxuICAgIGV4ZXJjaXNlc0J5VHlwZVthWzBdIGFzIEV4ZXJjaXNlVHlwZV0gPiBleGVyY2lzZXNCeVR5cGVbYlswXSBhcyBFeGVyY2lzZVR5cGVdID8gYSA6IGJcbiAgKVswXSBhcyBFeGVyY2lzZVR5cGU7XG5cbiAgLy8gQ291bnQgZXhlcmNpc2VzIGJ5IGludGVuc2l0eVxuICBjb25zdCBpbnRlbnNpdHlEaXN0cmlidXRpb24gPSBleGVyY2lzZXMucmVkdWNlKChjb3VudHMsIGV4KSA9PiB7XG4gICAgY291bnRzW2V4LmludGVuc2l0eV0gPSAoY291bnRzW2V4LmludGVuc2l0eV0gfHwgMCkgKyAxO1xuICAgIHJldHVybiBjb3VudHM7XG4gIH0sIHt9IGFzIFJlY29yZDxJbnRlbnNpdHlMZXZlbCwgbnVtYmVyPik7XG5cbiAgLy8gQ2FsY3VsYXRlIHN0cmVha3NcbiAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICBjb25zdCB1bmlxdWVEYXRlcyA9IEFycmF5LmZyb20obmV3IFNldChleGVyY2lzZXMubWFwKGV4ID0+IGV4LmRhdGUudG9EYXRlU3RyaW5nKCkpKSlcbiAgICAuc29ydCgoYSwgYikgPT4gbmV3IERhdGUoYikuZ2V0VGltZSgpIC0gbmV3IERhdGUoYSkuZ2V0VGltZSgpKTtcblxuICBsZXQgY3VycmVudFN0cmVhayA9IDA7XG4gIGxldCBsb25nZXN0U3RyZWFrID0gMDtcbiAgbGV0IHRlbXBTdHJlYWsgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdW5pcXVlRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBleGVyY2lzZURhdGUgPSBuZXcgRGF0ZSh1bmlxdWVEYXRlc1tpXSk7XG4gICAgY29uc3QgZGF5c0RpZmYgPSBNYXRoLmZsb29yKCh0b2RheS5nZXRUaW1lKCkgLSBleGVyY2lzZURhdGUuZ2V0VGltZSgpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSk7XG4gICAgXG4gICAgaWYgKGkgPT09IDAgJiYgZGF5c0RpZmYgPD0gMSkge1xuICAgICAgY3VycmVudFN0cmVhayA9IDE7XG4gICAgICB0ZW1wU3RyZWFrID0gMTtcbiAgICB9IGVsc2UgaWYgKGkgPiAwKSB7XG4gICAgICBjb25zdCBwcmV2RGF0ZSA9IG5ldyBEYXRlKHVuaXF1ZURhdGVzW2kgLSAxXSk7XG4gICAgICBjb25zdCBkYXlzQmV0d2VlbiA9IE1hdGguZmxvb3IoKHByZXZEYXRlLmdldFRpbWUoKSAtIGV4ZXJjaXNlRGF0ZS5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKTtcbiAgICAgIFxuICAgICAgaWYgKGRheXNCZXR3ZWVuID09PSAxKSB7XG4gICAgICAgIHRlbXBTdHJlYWsrKztcbiAgICAgICAgaWYgKGkgPT09IDEgJiYgZGF5c0RpZmYgPD0gMSkge1xuICAgICAgICAgIGN1cnJlbnRTdHJlYWsgPSB0ZW1wU3RyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb25nZXN0U3RyZWFrID0gTWF0aC5tYXgobG9uZ2VzdFN0cmVhaywgdGVtcFN0cmVhayk7XG4gICAgICAgIHRlbXBTdHJlYWsgPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsb25nZXN0U3RyZWFrID0gTWF0aC5tYXgobG9uZ2VzdFN0cmVhaywgdGVtcFN0cmVhaywgY3VycmVudFN0cmVhayk7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoaXMgd2VlaydzIGV4ZXJjaXNlc1xuICBjb25zdCB3ZWVrU3RhcnQgPSBuZXcgRGF0ZSh0b2RheSk7XG4gIHdlZWtTdGFydC5zZXREYXRlKHRvZGF5LmdldERhdGUoKSAtIHRvZGF5LmdldERheSgpKTtcbiAgd2Vla1N0YXJ0LnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICBcbiAgY29uc3QgZXhlcmNpc2VzVGhpc1dlZWsgPSBleGVyY2lzZXMuZmlsdGVyKGV4ID0+IGV4LmRhdGUgPj0gd2Vla1N0YXJ0KS5sZW5ndGg7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoaXMgbW9udGgncyBleGVyY2lzZXNcbiAgY29uc3QgbW9udGhTdGFydCA9IG5ldyBEYXRlKHRvZGF5LmdldEZ1bGxZZWFyKCksIHRvZGF5LmdldE1vbnRoKCksIDEpO1xuICBjb25zdCBleGVyY2lzZXNUaGlzTW9udGggPSBleGVyY2lzZXMuZmlsdGVyKGV4ID0+IGV4LmRhdGUgPj0gbW9udGhTdGFydCkubGVuZ3RoO1xuXG4gIC8vIENhbGN1bGF0ZSB3ZWVrbHkgZ29hbCBwcm9ncmVzcyAoYXNzdW1pbmcgNSBleGVyY2lzZXMgcGVyIHdlZWspXG4gIGNvbnN0IHdlZWtseUdvYWxQcm9ncmVzcyA9IE1hdGgubWluKDEwMCwgKGV4ZXJjaXNlc1RoaXNXZWVrIC8gNSkgKiAxMDApO1xuXG4gIC8vIEdlbmVyYXRlIHdlZWtseSBkYXRhIGZvciB0aGUgbGFzdCAxNCBkYXlzXG4gIGNvbnN0IHdlZWtseURhdGEgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDEzOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0b2RheSk7XG4gICAgZGF0ZS5zZXREYXRlKHRvZGF5LmdldERhdGUoKSAtIGkpO1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgXG4gICAgY29uc3QgbmV4dERheSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgIG5leHREYXkuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIDEpO1xuICAgIFxuICAgIGNvbnN0IGRheUV4ZXJjaXNlcyA9IGV4ZXJjaXNlcy5maWx0ZXIoZXggPT4gXG4gICAgICBleC5kYXRlID49IGRhdGUgJiYgZXguZGF0ZSA8IG5leHREYXlcbiAgICApO1xuICAgIFxuICAgIHdlZWtseURhdGEucHVzaCh7XG4gICAgICBkYXRlOiBkYXRlLnRvSVNPU3RyaW5nKCksXG4gICAgICBleGVyY2lzZXM6IGRheUV4ZXJjaXNlcy5sZW5ndGgsXG4gICAgICBkdXJhdGlvbjogZGF5RXhlcmNpc2VzLnJlZHVjZSgoc3VtLCBleCkgPT4gc3VtICsgZXguZHVyYXRpb24sIDApXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvdGFsRXhlcmNpc2VzLFxuICAgIHRvdGFsRHVyYXRpb24sXG4gICAgYXZlcmFnZUludGVuc2l0eSxcbiAgICBmYXZvcml0ZVR5cGUsXG4gICAgY3VycmVudFN0cmVhayxcbiAgICBsb25nZXN0U3RyZWFrLFxuICAgIHdlZWtseUdvYWxQcm9ncmVzcyxcbiAgICBleGVyY2lzZXNUaGlzV2VlayxcbiAgICBleGVyY2lzZXNUaGlzTW9udGgsXG4gICAgZXhlcmNpc2VzQnlUeXBlLFxuICAgIGludGVuc2l0eURpc3RyaWJ1dGlvbixcbiAgICB3ZWVrbHlEYXRhXG4gIH07XG59XG5cbi8vIEdldCBkZWZhdWx0IHR5cGUtc3BlY2lmaWMgZGF0YSBmb3IgZm9ybXNcbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0VHlwZURhdGEodHlwZTogRXhlcmNpc2VUeXBlKTogUGFydGlhbDxFeGVyY2lzZVsndHlwZVNwZWNpZmljRGF0YSddPiB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgRXhlcmNpc2VUeXBlLkhJSVQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb3VuZHM6IDAsXG4gICAgICAgIHdvcmtJbnRlcnZhbDogMCxcbiAgICAgICAgcmVzdEludGVydmFsOiAwXG4gICAgICB9O1xuICAgIGNhc2UgRXhlcmNpc2VUeXBlLldFSUdIVExJRlRJTkc6XG4gICAgY2FzZSBFeGVyY2lzZVR5cGUuQVJNUzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4ZXJjaXNlczogW10sXG4gICAgICAgIHRvdGFsV2VpZ2h0OiAwXG4gICAgICB9O1xuICAgIGNhc2UgRXhlcmNpc2VUeXBlLkNBUkRJTzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc3RhbmNlOiAwLFxuICAgICAgICBwYWNlOiAwLFxuICAgICAgICBoZWFydFJhdGU6IFtdXG4gICAgICB9O1xuICAgIGNhc2UgRXhlcmNpc2VUeXBlLlNQT1JUUzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNwb3J0OiAnJyxcbiAgICAgICAgc2NvcmU6ICcnLFxuICAgICAgICBvcHBvbmVudDogJydcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7fTtcbiAgfVxufVxuXG4vLyBEZWZhdWx0IGV4cG9ydCBvYmplY3RcbmNvbnN0IGV4ZXJjaXNlU2VydmljZSA9IHtcbiAgY3JlYXRlRXhlcmNpc2UsXG4gIGdldEV4ZXJjaXNlcyxcbiAgdXBkYXRlRXhlcmNpc2UsXG4gIGRlbGV0ZUV4ZXJjaXNlLFxuICBnZXRFeGVyY2lzZVN0YXRzLFxuICBnZXREZWZhdWx0VHlwZURhdGFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGV4ZXJjaXNlU2VydmljZTsiXSwibmFtZXMiOlsiRXhlcmNpc2VUeXBlIiwiSW50ZW5zaXR5TGV2ZWwiLCJFWEVSQ0lTRVNfU1RPUkFHRV9LRVkiLCJnZXRTdG9yZWRFeGVyY2lzZXMiLCJzdG9yZWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiZXhlcmNpc2VzIiwiSlNPTiIsInBhcnNlIiwibWFwIiwiZXhlcmNpc2UiLCJkYXRlIiwiRGF0ZSIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsInNhdmVFeGVyY2lzZXMiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiZ2VuZXJhdGVNb2NrRXhlcmNpc2VzIiwidXNlcklkIiwibm93IiwibW9ja0V4ZXJjaXNlcyIsImlkIiwidHlwZSIsIkhJSVQiLCJuYW1lIiwiZHVyYXRpb24iLCJpbnRlbnNpdHkiLCJISUdIIiwiZ2V0VGltZSIsIm5vdGVzIiwiY2Fsb3JpZXNCdXJuZWQiLCJ0eXBlU3BlY2lmaWNEYXRhIiwicm91bmRzIiwid29ya0ludGVydmFsIiwicmVzdEludGVydmFsIiwiV0VJR0hUTElGVElORyIsIk1PREVSQVRFIiwic2V0cyIsInJlcHMiLCJ3ZWlnaHQiLCJyZXN0VGltZSIsInRvdGFsV2VpZ2h0IiwiQ0FSRElPIiwiZGlzdGFuY2UiLCJwYWNlIiwiaGVhcnRSYXRlIiwiY3JlYXRlRXhlcmNpc2UiLCJmb3JtRGF0YSIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIm5ld0V4ZXJjaXNlIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwidHJpbSIsInVuZGVmaW5lZCIsInVuc2hpZnQiLCJnZXRFeGVyY2lzZXMiLCJmaWx0ZXJzIiwiZmlsdGVyIiwiZXgiLCJzZWFyY2hRdWVyeSIsInF1ZXJ5IiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsImRhdGVSYW5nZSIsInN0YXJ0IiwiZW5kIiwic29ydCIsImEiLCJiIiwidXBkYXRlRXhlcmNpc2UiLCJleGVyY2lzZUlkIiwidXBkYXRlcyIsImV4ZXJjaXNlSW5kZXgiLCJmaW5kSW5kZXgiLCJFcnJvciIsInVwZGF0ZWRFeGVyY2lzZSIsImRlbGV0ZUV4ZXJjaXNlIiwiZmlsdGVyZWRFeGVyY2lzZXMiLCJsZW5ndGgiLCJnZXRFeGVyY2lzZVN0YXRzIiwidG90YWxFeGVyY2lzZXMiLCJ0b3RhbER1cmF0aW9uIiwiYXZlcmFnZUludGVuc2l0eSIsImZhdm9yaXRlVHlwZSIsImN1cnJlbnRTdHJlYWsiLCJsb25nZXN0U3RyZWFrIiwid2Vla2x5R29hbFByb2dyZXNzIiwiZXhlcmNpc2VzVGhpc1dlZWsiLCJleGVyY2lzZXNUaGlzTW9udGgiLCJleGVyY2lzZXNCeVR5cGUiLCJpbnRlbnNpdHlEaXN0cmlidXRpb24iLCJ3ZWVrbHlEYXRhIiwicmVkdWNlIiwic3VtIiwiaW50ZW5zaXR5VmFsdWVzIiwiTE9XIiwiTUFYSU1VTSIsImNvdW50cyIsIk9iamVjdCIsImVudHJpZXMiLCJ0b2RheSIsInVuaXF1ZURhdGVzIiwiQXJyYXkiLCJmcm9tIiwiU2V0IiwidG9EYXRlU3RyaW5nIiwidGVtcFN0cmVhayIsImkiLCJleGVyY2lzZURhdGUiLCJkYXlzRGlmZiIsImZsb29yIiwicHJldkRhdGUiLCJkYXlzQmV0d2VlbiIsIm1heCIsIndlZWtTdGFydCIsInNldERhdGUiLCJnZXREYXRlIiwiZ2V0RGF5Iiwic2V0SG91cnMiLCJtb250aFN0YXJ0IiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsIm1pbiIsIm5leHREYXkiLCJkYXlFeGVyY2lzZXMiLCJwdXNoIiwidG9JU09TdHJpbmciLCJnZXREZWZhdWx0VHlwZURhdGEiLCJBUk1TIiwiU1BPUlRTIiwic3BvcnQiLCJzY29yZSIsIm9wcG9uZW50IiwiZXhlcmNpc2VTZXJ2aWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/services/exerciseService.ts\n"));

/***/ })

});